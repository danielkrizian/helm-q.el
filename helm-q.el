;;; helm-q.el --- A library to manage remote q sessions with Helm and q-mode  -*- lexical-binding: t; -*-

;; URL: https://github.com/emacs-q/helm-q.el
;; Package-Requires: ((emacs "26.1") (cl-lib "0.6") (helm "1.9.4") (s "1.10.0"))

;;; Commentary:

;; helm-q is an Emacs Lisp library to manage remote q sessions with Helm and q-mode.

;;; Code:

;; The code is automatically generated by function `literate-elisp-tangle' from file `helm-q.org'.
;; It is not designed to be readable by a human.
;; It is generated to load by Emacs directly without depending on `literate-elisp'.
;; you should read file `helm-q.org' to find out the usage and implementation detail of this source file.


(require 's)
(require 'helm)
(require 'q-mode)

(defgroup helm-q nil
  "Helm mode for managing kdb+/q instances"
  :group 'helm)
(defcustom helm-q-config-directory "~/.helm-q/"
  "The directory containing kdb connection files"
  :group 'helm-q
  :type 'string)

(defclass helm-q-source (helm-source-sync)
  ((instance-list
    :initarg :instance-list
    :initform #'helm-q-instance-list
    :custom function
    :documentation
    "  A function with no arguments to create instance list.")
   (candidate-columns
    :initform '(address service env region)
    :documentation "The columns used to display each candidate.")
   (candidate-columns-width-hash
    :initform (make-hash-table :test 'equal)
    :documentation "The width of each column in candidate-columns, key is the column symbol and value is the width of it.")
   (init :initform 'helm-q-source-list--init)
   (multimatch :initform nil)
   (multiline :initform t)
   (match :initform 'helm-q-source-match-function)
   (action :initform 'helm-q-source-list-persistent-action)
   (filtered-candidate-transformer :initform  'helm-q-source-filtered-candidate-transformer)
   (migemo :initform 'nomultimatch)
   (volatile :initform t)
   (nohighlight :initform nil)
   ))

(defun helm-q-calculate-columns-width (instances)
  "Calculate columns width.
Argument INSTANCES: the instance list."
  (cl-loop with width-hash = (helm-attr 'candidate-columns-width-hash)
           for column in (helm-attr 'candidate-columns)
           do (cl-loop for instance in instances
                       for width = (length (cdr (assoc column instance)))
                       if (or (null (gethash column width-hash))
                              (> width (gethash column width-hash)))
                       do (setf (gethash column width-hash) width))))

(defun helm-q-instance-display-string (instance)
  "Argument INSTANCE: one instance."
  (let ((first-row (s-join helm-buffers-column-separator
                           (cl-loop for column in (helm-attr 'candidate-columns)
                                    collect (helm-substring-by-width (format "%s" (cdr (assoc column instance)))
                                                                     (gethash column (helm-attr 'candidate-columns-width-hash))))))
        (context-matched-columns (helm-q-context-matched-columns instance)))
    (propertize 
     (if (null context-matched-columns)
       first-row
       (concat first-row "\n"
               (s-join helm-buffers-column-separator
                       (cons helm-buffers-column-separator
                             context-matched-columns))))
     'instance instance)))

(defun helm-q-instance-list ()
  "Load source from json files in a directory."
  (require 'json)
  (let ((instances (cl-loop for file in (directory-files helm-q-config-directory t ".json$")
                            append (cl-loop for instance across (json-read-file file)
                                            collect instance))))
    (helm-q-calculate-columns-width instances)
    ;; a list whose members are `(DISPLAY . REAL)' pairs.
    (cl-loop for instance in instances
             collect (cons (helm-q-instance-display-string instance) instance))))

(defun helm-q-source-list--init ()
  "Initialize helm-q-source."
  (helm-attrset 'candidates (funcall (helm-attr 'instance-list))))

(defun helm-q-get-instance-by-display (display-str)
  "Get an instance by its display string.
Argument DISPLAY-STR: the display string."
  (cl-loop with candidates = (helm-attr 'candidates)
           for candidate in candidates
           when (string= display-str (car candidate))
           return (cdr candidate)))

(defun helm-q-context-matched-columns (instance)
  "Return a list of string for matched columns.
Argument INSTANCE: one instance."
  (unless (s-blank? helm-pattern)
    (append 
     (cl-loop for table-columns in (cdr (assoc 'tablescolumns instance))
              append (append (let ((tab-name (format "%s" (car table-columns))))
                               (if (helm-buffer--match-pattern helm-pattern tab-name nil)
                                 (list (format "Table:'%s'" tab-name))))
                             (cl-loop for column-name across (cdr table-columns)
                                      if (helm-buffer--match-pattern helm-pattern column-name nil)
                                      collect (format "Column:'%s'" column-name))))
     (cl-loop for (function) in (cdr (assoc 'functions instance))
              for function-name = (format "%s" function)
              if (helm-buffer--match-pattern helm-pattern function-name nil)
              collect (format "Function:'%s'" function-name))

     (cl-loop for variable-name across (cdr (assoc 'variables instance))
              if (helm-buffer--match-pattern helm-pattern variable-name nil)
              collect (format "Var:'%s'" variable-name)))))

(defun helm-q-source-match-function (candidate)
  "Default function to match buffers.
Argument CANDIDATE: one helm candidate."
  (let ((instance (helm-q-get-instance-by-display candidate))
        (helm-buffers-fuzzy-matching t))
    (or 
      (cl-loop for slot in (helm-attr 'candidate-columns)
               for slot-value = (cdr (assoc slot instance))
               thereis (helm-buffer--match-pattern helm-pattern slot-value nil))
      (helm-q-context-matched-columns instance))))

(defun helm-q-source-filtered-candidate-transformer (candidates source)
  "Filter candidates by context match.
Argument CANDIDATES: the candidate list.
Argument SOURCE: the source."
  (cl-loop for (nil . instance) in candidates
           collect (cons (helm-q-instance-display-string instance) instance)))

(defun helm-q-source-list-persistent-action (candidate)
  "Argument CANDIDATE: selected candidate."
  (let* ((instance candidate)
         (address (cdr (assoc 'address instance))))
    (message "connect to q: %s" address)
    (q-qcon address)))

(defun helm-q ()
  "Select data source in helm."
  (interactive)
  (helm :sources (helm-make-source "helm-q" 'helm-q-source)
        :buffer "*helm q*"))


(provide 'helm-q)
;;; helm-q.el ends here
