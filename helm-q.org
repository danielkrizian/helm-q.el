# -*- encoding:utf-8 Mode: POLY-ORG; org-src-preserve-indentation: t; -*- ---
#+TITLE: Manage remote q sessions with Helm and q-mode
#+OPTIONS: toc:2
#+Startup: noindent
#+LATEX_HEADER: % copied from lstlang1.sty, to add new language support to Emacs Lisp.
#+LATEX_HEADER: \lstdefinelanguage{elisp}[]{lisp} {}
#+LATEX_HEADER: \lstloadlanguages{elisp}
#+PROPERTY: header-args :results silent
#+PROPERTY: literate-lang elisp
#+PROPERTY: literate-load yes

* Table of Contents                                            :TOC:noexport:
- [[#preparation][Preparation]]
  - [[#how-to-develop-with-helm][how to develop with helm]]
  - [[#load-dependencies][load dependencies]]
  - [[#custom-variables][custom variables]]
- [[#usage][Usage]]
- [[#implementation][implementation]]
  - [[#helm-q-buffer-class][helm-q buffer class]]
  - [[#how-to-display-a-q-instance-in-helm-buffer][how to display a q instance in helm buffer]]
  - [[#setup-instance-list][setup instance list]]
  - [[#initialize-helm-q-source][initialize helm-q-source]]
  - [[#get-one-instance-by-its-candidate-display-string][get one instance by its candidate display string]]
  - [[#match-funtion][match funtion]]
  - [[#default-persistent-action-to-connect-with-q-mode][default persistent action to connect with q-mode]]
  - [[#the-interactive-command][The interactive command]]
- [[#release-current-library][Release current library]]

* Preparation
** how to develop with helm
https://github.com/emacs-helm/helm/wiki/Developing
** load dependencies 
#+BEGIN_SRC elisp
(require 'helm)
(require 'q-mode)
#+END_SRC
** custom variables
#+BEGIN_SRC elisp
(defgroup helm-q nil
  "Helm mode for managing kdb+/q instances"
  :group 'helm)
(defcustom helm-q-config-directory "~/.helm-q/"
  "The directory containing kdb connection files"
  :group 'helm-q
  :type 'string)
#+END_SRC
* Usage
1. Put some JSON files with the same format as it is in [[./instances-meta.json]] to directory =~/.helm-q=.
2. In Emacs, load ~helm-q.el~ by invoking command ~load-file~.
3. Execute command ~helm-q~.
* implementation
** helm-q buffer class
#+BEGIN_SRC elisp
(defclass helm-q-source (helm-source-sync)
  ((instance-list
    :initarg :instance-list
    :initform #'helm-q-instance-list
    :custom function
    :documentation
    "  A function with no arguments to create instance list.")
   (candidate-columns
    :initform '(address service env region)
    :documentation "The columns used to display each candidate.")
   (candidate-columns-width-hash
    :initform (make-hash-table :test 'equal)
    :documentation "The width of each column in candidate-columns, key is the column symbol and value is the width of it.")
   (init :initform 'helm-q-source-list--init)
   (multimatch :initform nil)
   (match :initform 'helm-q-source-match-function)
   (action :initform 'helm-q-source-list-persistent-action)
   (migemo :initform 'nomultimatch)
   (volatile :initform t)
   (nohighlight :initform nil)
   ))
#+END_SRC
** how to display a q instance in helm buffer
we will calculate the maximum width of each column to make sure each column will display with same width.
That is, each column will have a width which is the maximum one in all the instances.
#+BEGIN_SRC elisp
(defun helm-q-calculate-columns-width (instances)
  "Calculate columns width.
Argument INSTANCES: the instance list."
  (cl-loop with width-hash = (helm-attr 'candidate-columns-width-hash)
           for column in (helm-attr 'candidate-columns)
           do (cl-loop for instance in instances
                       for width = (length (cdr (assoc column instance)))
                       if (or (null (gethash column width-hash))
                              (> width (gethash column width-hash)))
                       do (setf (gethash column width-hash) width))))
#+END_SRC

#+BEGIN_SRC elisp
(defun helm-q-instance-display-string (instance)
  "Argument INSTANCE: one instance."
  (mapconcat 'identity
             (cl-loop for column in (helm-attr 'candidate-columns)
                      collect (helm-substring-by-width (format "%s" (cdr (assoc column instance)))
                                                       (gethash column (helm-attr 'candidate-columns-width-hash))))
             helm-buffers-column-separator))
#+END_SRC
** setup instance list
#+BEGIN_SRC elisp
(defun helm-q-instance-list ()
  "Load source from json files in a directory."
  (require 'json)
  (let ((instances (cl-loop for file in (directory-files helm-q-config-directory t ".json$")
                            append (cl-loop for instance across (json-read-file file)
                                            collect instance))))
    (helm-q-calculate-columns-width instances)
    ;; a list whose members are `(DISPLAY . REAL)' pairs.
    (cl-loop for instance in instances
             collect (cons (helm-q-instance-display-string instance) instance))))
#+END_SRC
** initialize helm-q-source
#+BEGIN_SRC elisp
(defun helm-q-source-list--init ()
  "Initialize helm-q-source."
  (helm-attrset 'candidates (funcall (helm-attr 'instance-list))))
#+END_SRC
** get one instance by its candidate display string
#+BEGIN_SRC elisp
(defun helm-q-get-instance-by-display (display-str)
  (cl-loop with candidates = (helm-attr 'candidates (helm-get-current-source))
           for candidate in candidates
           when (string= display-str (car candidate))
           return (cdr candidate)))
#+END_SRC
** match funtion
#+BEGIN_SRC elisp
(defun helm-q-source-match-function (candidate)
  "Default function to match buffers.
Argument CANDIDATE: one helm candidate."
  (let ((instance (helm-q-get-instance-by-display candidate))
        (helm-buffers-fuzzy-matching t))
    (or 
      (cl-loop for slot in '(env region service address)
               for slot-value = (cdr (assoc slot instance))
               thereis (helm-buffer--match-pattern helm-pattern slot-value nil))

      (cl-loop for table-columns in (cdr (assoc 'tablescolumns instance))
               thereis (or (let ((tab-name (format "%s" (car table-columns))))
                             (helm-buffer--match-pattern helm-pattern tab-name nil))
                           (cl-loop for column-name across (cdr table-columns)
                                    thereis (helm-buffer--match-pattern helm-pattern column-name nil))))

      (cl-loop for (function) in (cdr (assoc 'functions instance))
               for function-name = (format "%s" function)
               thereis (helm-buffer--match-pattern helm-pattern function-name nil))

      (cl-loop for variable-name across (cdr (assoc 'variables instance))
               thereis (helm-buffer--match-pattern helm-pattern variable-name nil))
      
      )))
#+END_SRC
** default persistent action to connect with q-mode 
#+BEGIN_SRC elisp
(defun helm-q-source-list-persistent-action (candidate)
  "Argument CANDIDATE: selected candidate."
  (let* ((instance candidate)
         (address (cdr (assoc 'address instance))))
    (message "connect to q %s" address)
    (q-qcon address)))
#+END_SRC
** The interactive command
#+BEGIN_SRC elisp
;;;###autoload
(defun helm-q ()
  "Select data source in helm."
  (interactive)
  (helm :sources (helm-make-source "helm-q" 'helm-q-source)
        :buffer "*helm q*"))
#+END_SRC
* Release current library
And when a new version of [[./helm-q.el]] can release from this file,
the following code should execute.
#+BEGIN_SRC elisp :load no
(literate-elisp-tangle
 "helm-q.org"
 :header ";;; helm-q.el --- A library to manage remote q sessions with Helm and q-mode  -*- lexical-binding: t; -*-

;; URL: https://github.com/emacs-q/helm-q.el
;; Package-Requires: ((cl-lib \"0.6\") (emacs \"26.1\"))

;;; Commentary:

;; helm-q is an Emacs Lisp library to manage remote q sessions with Helm and q-mode.
"
                 :tail "(provide 'helm-q)
;;; helm-q.el ends here
")
#+END_SRC
